# Домашнее задание к занятию "3.2. Работа в терминале, лекция 2"
# Какого типа команда cd? Попробуйте объяснить, почему она именно такого типа; опишите ход своих мыслей, если считаете что она могла бы быть другого типа.

#vagrant@vagrant:~$ type cd
#cd is a shell builtin - встроенная функция в оболочку
#может работать по разному в зависимости от оболочки (Bourne shell, csh, tcsh, bash и в DOS)
#если бы она была внешняя, то необходимо было бы дополнительно подключать свою оболочку для получения желаемого еффекта поведения (например: в сессии DOS (общепринятый «домашний каталог» отсутствует и зависит от конкретной реализации)), также cd даёт различный эффект в разных операционных системах, поэтому для удобства cd является встроенной функицей в каждую оболочку.

# Какая альтернатива без pipe команде grep <some_string> <some_file> | wc -l? man grep поможет в ответе на этот вопрос. Ознакомьтесь с документом о других подобных некорректных вариантах использования pipe.
#vagrant@vagrant:~$ cat  /var/log/syslog | grep error - чтение и поиск в нем ключевого слова error
#vagrant@vagrant:~$ cat  /var/log/syslog | grep -i error - чтение и поиск в нем ключевого слова error невзирая на регистр
#Можно файл передать утилите grep в качестве аргумента:
#vagrant@vagrant:~$ grep -i error /var/log/syslog

#Можно выполнять поиск по маске, по набору файлов:
#vagrant@vagrant:~$ sudo grep -i error /var/log/*
#grep: /var/log/journal: Is a directory - может выдавать ошибку что grep не может прочитать директорию 
#vagrant@vagrant:~$ sudo grep -ir error /var/log/* - ключ -ir дает возможность заглянуть в каждую директорию и найти там, при этом ошибок что он не может прочитать директорию не будет
#vagrant@vagrant:~$ sudo grep -ir error /var/log/* | grep RAS: - выведет все строки с ключевым словом RAS:
#vagrant@vagrant:~$ sudo grep -ir error /var/log/* | grep RAS: | wc -l - выведет все строки с ключевым словом RAS: и подсчитает кол-во таких строк
#vagrant@vagrant:~$ cat /var/log/syslog | grep -A 2 error - выведет 2 строки после найденного вхождения
#vagrant@vagrant:~$ cat /var/log/syslog | grep -B 2 error - выведет 2 строки до найденного вхождения
#vagrant@vagrant:~$ cat /var/log/syslog | grep -С 2 error - выведет 2 строки до и после найденного вхождения


# Какой процесс с PID 1 является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?
#systemd(1)─┬─VBoxService(893)─┬─{VBoxService}(895)
           │                  ├─{VBoxService}(896)
           │                  ├─{VBoxService}(897)
           │                  ├─{VBoxService}(898)
           │                  ├─{VBoxService}(899)
           │                  ├─{VBoxService}(900)
           │                  ├─{VBoxService}(901)
           │                  └─{VBoxService}(902)


# Как будет выглядеть команда, которая перенаправит вывод stderr ls на другую сессию терминала?

#vagrant@vagrant:~$ tty
#/dev/pts/0
#vagrant@vagrant:~$ ls -l 14.file 2>/dev/pts/1

#vagrant@vagrant:~$ tty
#/dev/pts/1
#vagrant@vagrant:~$ ls: cannot access '14.file': No such file or directory


# Получится ли одновременно передать команде файл на stdin и вывести ее stdout в другой файл? Приведите работающий пример.

#vagrant@vagrant:~$ cat 11.file
#insert to 14.file
#vagrant@vagrant:~$ cat 14.file
#cat: 14.file: No such file or directory
#vagrant@vagrant:~$ less <11.file >14.file
#vagrant@vagrant:~$ cat 14.file
#insert to 14.file

# Получится ли находясь в графическом режиме, вывести данные из PTY в какой-либо из эмуляторов TTY? Сможете ли вы наблюдать выводимые данные?

#vagrant@vagrant:~$ tty
#/dev/pts/0
#vagrant@vagrant:~$ echo "Hello!" > /dev/tty1-7 (By default Ubuntu has 7 tty's.)

#vagrant@vagrant:~$ ls -l /dev/std*
#lrwxrwxrwx 1 root root 15 Mar 27 11:41 /dev/stderr -> /proc/self/fd/2
#lrwxrwxrwx 1 root root 15 Mar 27 11:41 /dev/stdin -> /proc/self/fd/0
#lrwxrwxrwx 1 root root 15 Mar 27 11:41 /dev/stdout -> /proc/self/fd/1
#bash 5>&1 - созданный файловый дескриптор 5 получит поток stdout
#echo netology > /proc/$$/fd/5 - выведет "netology" т.к. поток stout был перенаправлен на предыдущем шаге



# Получится ли в качестве входного потока для pipe использовать только stderr команды, не потеряв при этом отображение stdout на pty? Напоминаем: по умолчанию через pipe передается только stdout команды слева от | на stdin команды справа. Это можно сделать, поменяв стандартные потоки местами через промежуточный новый дескриптор, который вы научились создавать в предыдущем вопросе.

#vagrant@vagrant:/$ ls -l /~.bashrc 7>&2 2>&1 1>&7 |grep No
#ls: cannot access '/~.bashrc': No such file or directory
#7>&2 - новый fd9 перенаправили в stderr 
#2>&1 - stderr пернаправли в stdout
#1>&7 - stdout пернаправили в новый файловый дескриптор

# Что выведет команда cat /proc/$$/environ? Как еще можно получить аналогичный по содержанию вывод?
#Будут выведены переменные окружения, тоже самое только с разделениями можно вывести командой env

# Используя man, опишите что доступно по адресам /proc/<PID>/cmdline, /proc/<PID>/exe
#/proc/[pid]/cmdline
#Этот доступный только для чтения файл содержит полную командную строку для процесса, если этот процесс не является 
#зомби. В последнем случае в этом файле ничего нет: то есть чтение этого файла вернет 0 символов. Аргументы командной 
#строки отображаются в этом файле как набор строк, разделенных нулевыми байтами ('\0'), с дополнительным нулевым 
#байтом после последней строки.

#/proc/[pid]/exe
#В Linux 2.2 и более поздних версиях этот файл представляет собой символическую ссылку, содержащую фактический путь 
#к выполняемой команде. Эта символическая ссылка может быть разыменована обычным образом; попытка открыть его откроет 
#исполняемый файл. Вы даже можете ввести /proc/[pid]/exe, чтобы запустить другую копию того же исполняемого файла, 
#который запускается процессом [pid]. Если путь был несвязан, символическая ссылка будет содержать строку 
#«(удалено)», добавленную к исходному имени пути. В многопоточном процессе содержимое этой символической ссылки 
#недоступно, если основной поток уже завершен

# Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью /proc/cpuinfo
#vagrant@vagrant:~$ grep sse /proc/cpuinfo
#..sse4_2...

